Задача: Редизайн админ-экрана «Настройка цен и этапов» (без JSON в UI)
Контекст

Сейчас в админке для каждой услуги/этапа (poem/voice/song/clip) показывается textarea с JSON. Это неудобно: администратор не должен видеть коды/ключи/экранированные строки. Нужно заменить JSON-редактор на понятные поля формы.

Цель

Сделать интерфейс, в котором админ:

видит список услуг с человеческими названиями;

может включать/выключать услугу;

может быстро изменить цену (и при необходимости — «Название для клиента»);

сохраняет изменения одной кнопкой, получая понятный статус/ошибки.

Требования к UI/UX
1) Таблица/список настроек

Отображать настройки в виде таблицы или карточек (по дизайн-системе проекта):

Колонки (минимум):

Услуга (человеческое название + мелким шрифтом ключ, например: “Стихотворение (poem)”)

Активно (toggle switch)

Цена (числовое поле + валюта “₽”/“RUB”)

Название для клиента (text input) — если это реально используется

Действия: “Сохранить” (или “Сохранить все” сверху)

JSON/textarea в интерфейсе не показывать вообще.

2) Редактирование цены

Поле Цена: type=number, step=1 (или 0.01 если нужны копейки), min=0.

Отображение: аккуратный инпут с суффиксом валюты.

При вводе — локальная валидация (нечисло/пусто/отрицательное).

3) Нормальные названия (без \u0421…)

На клиенте отображать title в нормальном виде (декодировать, если с сервера приходит unicode-escape).

Если title отсутствует — показать дефолт “poem / voice / …” или маппинг.

4) Сохранение

Варианты (выберите один и реализуйте):

A. Сохранить по строке: кнопка “Сохранить” в каждой строке, активна только если есть изменения в строке.

B. Сохранить все: одна кнопка сверху/снизу, сохраняет все изменённые строки разом.

UX-детали:

Индикатор “Есть несохранённые изменения”.

Лоадер на время запроса.

Успешное сохранение: toast/alert “Сохранено”.

Ошибка: человекочитаемое сообщение + подсветка поля, если ошибка валидации.

5) Валидация и защита от ошибок

Цена не может быть отрицательной.

Пустая цена — запрещена (или трактуется как 0, если так задумано).

Если сервис выключен (enabled=false), цена может оставаться, но поле можно сделать disabled/readonly (по решению UX) — главное, чтобы было понятно.

6) Визуальный дизайн (минимальные требования)

Современная аккуратная админ-стилистика: отступы, типографика, одинаковые высоты инпутов, ясная иерархия.

На мобильных/узких экранах: таблица превращается в карточки (responsive).

Кнопки одного стиля, не “огромные синие на весь экран”, а пропорциональные.

Требования к данным и интеграции
1) API не меняем (если нельзя)

Если бэкенд сейчас ждёт JSON — фронт внутри себя собирает/разбирает объект, но пользователю не показывает.

Пример внутренней модели (для фронта):

type StageConfig = {
  key: 'poem' | 'voice' | 'song' | 'clip' | string;
  enabled: boolean;
  price: number;
  title: string; // отображаемое название
}

2) Парсинг/сериализация

При загрузке: распарсить текущие значения из ответа API.

При сохранении: отправить в API в нужном формате (как сейчас), но из полей формы.

3) Обработка «грязных» данных

Если приходит:

некорректный JSON,

отсутствует поле price/title/enabled,

title в unicode-escape,

то:

не падать,

показать безопасные дефолты,

подсветить проблему и дать возможность исправить через поля.

Acceptance Criteria (критерии приёмки)

На странице нет textarea/JSON редактора — админ видит только форму.

Для каждого ключа (poem/voice/song/clip) отображаются: активность, цена, (опц.) title.

Цена редактируется в 1–2 клика, ввод валидируется.

Сохранение работает, есть состояния: loading / success / error.

Названия отображаются нормально (без \u0421\u0442...).

Адаптивность: на узком экране UI остаётся удобным (карточки/перенос колонок).

Никакие “коды” и служебные данные не мешают пользователю.